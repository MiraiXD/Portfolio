// This script sits on both controllers, controls phases: holding, aiming, shooting generated by the controllers

using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class WandController : MonoBehaviour
{
    // WandController script sitting on the second controller
    [SerializeField]
    private WandController theOtherController;
    // SteamVR_TrackedObject script of this controller
    private SteamVR_TrackedObject trackedObj;
    // Property for getting this controller to handle input
    private SteamVR_Controller.Device controller { get { return SteamVR_Controller.Input((int)trackedObj.index); } }
    // ID of the trigger button
    private Valve.VR.EVRButtonId triggerButton = Valve.VR.EVRButtonId.k_EButton_SteamVR_Trigger;
    // Cuestick object
    private GameObject cueStick;
    // Cuestick RB
    private Rigidbody cueStickRigidBody;
    // Used to multiply the cueStickRigidBody.velocity to make it move fluently
    private int velocityMultiplier = 100;
    // The model of the stick
    private GameObject model;
    // Contains coroutins controlling the vibration of the controller
    protected Dictionary<SteamVR_Controller.Device, Coroutine> activeHapticCoroutines = new Dictionary<SteamVR_Controller.Device, Coroutine>();

    // The distance to move the model and the cueStick object to set a pivot point in the place where the controller touched the stick
    private float moveDistance;
    private Vector3 moveVector;

    // Is a controller in range of the stick's collider? Used to pick up the stick, then it's true
    private bool cueStickSelected = false;

    // Is this controller holding the stick?
    private bool holdingCueStick = false;
    // Second controller touched the cuestick, when this controller is holding it
    private bool secondControllerDetected = false;
    // In the aiming phase?
    public bool aiming = false;
    // Awaiting for a trigger button push to start shooting phase
    public bool aimingToShooting = false;
    // In the shooting phase?
    public bool shooting = false;
    // Vector pointing direction from the holding controller to the cueStick
    private Vector3 controllerCueStickDirection;
    // In shooting phase, the only direction (axis) the stick can move along
    private Vector3 shootingDirection;

    // Use this for initialization
    void Start()
    {
        trackedObj = GetComponent<SteamVR_TrackedObject>();
        cueStick = GameObject.Find("CueStickPrefab");
        cueStickRigidBody = cueStick.GetComponent<Rigidbody>();
        model = GameObject.Find("Model");
    }

    void Update()
    {
        if (controller == null)
        {
            Debug.Log("controller not working");
            return;
        }

        // This if handles button presses
        if (controller.GetPressDown(triggerButton) && cueStick != null)
        {
            pickUpTheStick();
            initAiming();
            initShooting();
        }        

        //This if is used when you rotate the stick - aiming
        if (aiming)
        {
            if (cueStick.transform.parent != null)
            {
                cueStick.transform.parent = null;
                cueStick.transform.position += moveDistance * cueStick.transform.TransformDirection(Vector3.forward);                
                model.transform.position -= moveDistance * cueStick.transform.forward;
                aimingToShooting = true;
            }
            cueStick.transform.LookAt(theOtherController.transform.position);
        }        

        // This if is used when you are moving the stick in one axis you chose in the aiming phase - shooting
        if (shooting)
        {
            Vector3 _target;
            if (theOtherController.isHolding())
            {
                controllerCueStickDirection = theOtherController.transform.position - cueStick.transform.position;
                controllerCueStickDirection /= controllerCueStickDirection.magnitude;
                _target = (shootingDirection * Vector3.Distance(cueStick.transform.position, theOtherController.transform.position) * Vector3.Dot(controllerCueStickDirection, shootingDirection));
                
                cueStickRigidBody.velocity = _target * velocityMultiplier;
            }
        }        t
    }



    void pickUpTheStick()
    {
        StopHapticVibration(controller);

        if (!theOtherController.isHolding())
        {
            if (cueStickSelected && !this.holdingCueStick)
            {
                StartHapticVibration(0.05f, 1);

                cueStick.transform.parent = this.transform;
                cueStick.transform.localPosition = Vector3.zero;
                cueStick.transform.localRotation = Quaternion.Euler(new Vector3(180, 0, 0));
                this.holdingCueStick = true;
            }
            else if (this.holdingCueStick)
            {
                StartHapticVibration(0.05f, 1);

                aiming = false;
                theOtherController.aiming = false;
                shooting = false;
                theOtherController.shooting = false;
                aimingToShooting = false;
                theOtherController.aimingToShooting = false;
                secondControllerDetected = false;
                this.holdingCueStick = false;

                model.transform.localPosition = Vector3.zero;
                cueStick.gameObject.GetComponent<CapsuleCollider>().enabled = true;
                cueStick.gameObject.GetComponent<Rigidbody>().velocity = Vector3.zero;
                cueStick.transform.parent = null;

            }
        }

    }

    void initAiming()
    {
        if (secondControllerDetected)
        {
            if (theOtherController.isHolding())
            {
                aiming = true;
                moveVector = this.transform.position - cueStick.transform.position;
                // Scalar product of two vectors = cosine(angleBetweenThem) * vector1.magnitude * vector2.magnitude (here - both magnitudes = 1)
                moveDistance = Vector3.Dot(moveVector / moveVector.magnitude, cueStick.transform.TransformDirection(Vector3.forward)) * moveVector.magnitude;
                secondControllerDetected = false;
                cueStick.gameObject.GetComponent<CapsuleCollider>().enabled = false;
            }
        }
    }

    void initShooting()
    {
        if (aimingToShooting)
        {
            aiming = false;
            shooting = true;
            shootingDirection = cueStick.transform.TransformDirection(Vector3.forward);
            cueStick.transform.position += moveDistance * cueStick.transform.TransformDirection(Vector3.back);
            //model.transform.Translate(-moveDistance * model.transform.InverseTransformDirection(cueStick.transform.TransformDirection(Vector3.back)));
            model.transform.localPosition = Vector3.zero;
            aimingToShooting = false;
        }
    }

    private void OnTriggerEnter(Collider collider)
    {
        if (collider.tag == "CueStick")
        {
            cueStickSelected = true;
        }
        else if (collider.tag == "SecondControllerDetector")
        {
            secondControllerDetected = true;
        }
    }

    private void OnTriggerExit(Collider collider)
    {
        if (collider.tag == "CueStick")
        {
            cueStickSelected = false;
            StopHapticVibration(controller);
        }
        else if (collider.tag == "SecondControllerDetector")
        {
            secondControllerDetected = false;
            StopHapticVibration(controller);
        }
    }

    private void OnTriggerStay(Collider collider)
    {
        if (collider.tag == "CueStick" && !holdingCueStick && !aiming && !aimingToShooting && !shooting)
        {
            StartHapticVibration(500, 0.05f);
        }
        else if (collider.tag == "SecondControllerDetector" && !holdingCueStick && !aiming && !aimingToShooting && !shooting)
        {
            StartHapticVibration(500, 0.05f);
        }
        else
        {
            StopHapticVibration(controller);

        }
    }

    public bool isHolding()
    {
        return holdingCueStick;
    }

    public void StartHapticVibration(float length, float strength)
    {
        if (activeHapticCoroutines.ContainsKey(controller))
        {
            //Debug.Log("This device is already vibrating");
            return;
        }
        Coroutine coroutine = StartCoroutine(StartHapticVibrationCoroutine(controller, length, strength));
        activeHapticCoroutines.Add(controller, coroutine);
    }

    public void StopHapticVibration(SteamVR_Controller.Device device)
    {
        if (!activeHapticCoroutines.ContainsKey(device))
        {
            //Debug.Log("Could not find this device");
            return;
        }
        StopCoroutine(activeHapticCoroutines[device]);
        activeHapticCoroutines.Remove(device);
    }
    protected IEnumerator StartHapticVibrationCoroutine(SteamVR_Controller.Device device, float length, float strength)
    {
        for (float i = 0; i < length; i += Time.deltaTime)
        {
            device.TriggerHapticPulse((ushort)Mathf.Lerp(0, 3999, strength));
            yield return null;
        }
        activeHapticCoroutines.Remove(device);
    }
}
